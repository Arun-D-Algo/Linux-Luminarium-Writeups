# Linux Luminarium
# Module 6: Practicing Piping

## Process Substitution for input
Sometimes you need to compare the output of two commands rather than two files. You might think to save each output to a file first:

hacker@dojo:~$ command1 > file1
hacker@dojo:~$ command2 > file2
hacker@dojo:~$ diff file1 file2
But there's a more elegant way! Linux follows the philosophy that "everything is a file". That is, the system strives to provide file-like access to most resources, including the input and output of running programs! The shell follows this philosophy, allowing you to, for example, use any utility that takes file arguments on the command line and hook it up to the output of programs, as you learned in the previous few levels.

Interestingly, we can go further, and hook input and output of programs to arguments of commands. This is done using Process Substitution. For reading from a command (input process substitution), use <(command). When you write <(command), bash will run the command and hook up its output to a temporary file that it will create. This isn't a real file, of course, it's what's called a named pipe, in that it has a file name:

hacker@dojo:~$ echo <(echo hi)
/dev/fd/63
hacker@dojo:~$
Where did /dev/fd/63 come from? bash replaced <(echo hi) with the path of the named pipe file that's hooked up to the command's output! While the command is running, reading from this file will read data from the standard output of the command. Typically, this is done using commands that take input files as arguments:

hacker@dojo:~$ cat <(echo hi)
hi
hacker@dojo:~$
Of course, you can specify this multiple times:

hacker@dojo:~$ echo <(echo pwn) <(echo college)
/dev/fd/63 /dev/fd/64
hacker@dojo:~$ cat <(echo pwn) <(echo college)
pwn
college
hacker@dojo:~$
Now for your challenge! Recall what you learned in the diff challenge from Comprehending Commands. In that challenge, you diffed two files. Now, you'll diff two sets of command outputs: /challenge/print_decoys, which will print a bunch of decoy flags, and /challenge/print_decoys_and_flag which will print those same decoys plus the real flag.

Use process substitution with diff to compare the outputs of these two programs and find your flag!


### Solve
**Flag:** `pwn.college{AhHe2GZ2BOS9Ko16m8Ulo2ChGD6.QXxITO0wiNyUDN0EzW}`

This challenge was solved by using tee to duplicate data flowing through a pipe without interrupting it. The output of /challenge/pwn was piped into tee, which saved a copy to a file for inspection while still passing the same data onward to /challenge/college. After inspecting the intercepted output and identifying the required secret argument, /challenge/pwn was re-run with the correct flag, allowing /challenge/college to validate the input and reveal the final flag.

```bash
hacker@piping~duplicating-piped-data-with-tee:~$ /challenge/pwn | tee pwn | /challenge/college
Processing...
The input to 'college' does not contain the correct secret code! This code 
should be provided by the 'pwn' command. HINT: use 'tee' to intercept the 
output of 'pwn' and figure out what the code needs to be.
hacker@piping~duplicating-piped-data-with-tee:~$ cat pwn 
Usage: /challenge/pwn --secret [SECRET_ARG]

SECRET_ARG should be "AhHe2GZ2"
hacker@piping~duplicating-piped-data-with-tee:~$ /challenge/pwn --secret AhHe2GZ2 | /challenge/college
Processing...
Correct! Passing secret value to /challenge/college...
Great job! Here is your flag:
pwn.college{AhHe2GZ2BOS9Ko16m8Ulo2ChGD6.QXxITO0wiNyUDN0EzW}
```

### New Learnings
Learned how tee duplicates piped data, allowing simultaneous inspection and forwarding of a stream. This reinforced how Unix pipelines can be debugged non-destructively by observing intermediate data without breaking the flow between commands.